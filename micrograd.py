# -*- coding: utf-8 -*-
"""micrograd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UDN18c6MpMylwWxEWA4UxmtJ1cHCyUss
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

def f(x):
  """
  Scalar value function, takes a single scalar (number representing magnitude or quantity) x and returns single scalar y
  """
  return 3*x**2 - 4*x + 5

f(3.0)

xs = np.arange(-5, 5, 0.25) # An array of the range from -5 to 5 with steps of 0.25 (not including 5)
ys = f(xs) # Array gets mapped as the input, and function gets applied individually for each elelment
           # returns an array with the results
ys

plt.plot(xs, ys) # x, y

h = 0.00000001 # Very close to zero
x = -3.0 #Our target val
f(x+h) # Slightly nudge x in a positive direction
# But how does it respond?
(f(x+h) - f(x))/h # This is how much it responded, and u normalize it via the run (rise/run for slope -> the direction it is changing or going in)
#Gives numerical representation of the slope, and closer to zero will tell u the value

# 3 scalars, and output variable d from them
a = 2.0
b = -3.0
c = 10.0
d = a * b + c
print(d)

h = 0.00001 # very small & close to zero

# inputs that are random vals
a = 2.0
b = -3.0
c = 10.0


d1 = a * b + c
a += h # bumping our input by a tiny amount
d2 = a * b + c

print('d1', d1)
print('d2', d2) # decreases, thus the slope is negative
print('slope', (d2-d1)/h) #how much the function increased from d1 to d2, then normalized for the slope

class Value:
  """
  Takes a single scalar value, to keep track of (essentially wraps it)

  Scalar value is taking in via data, and it is wrapped in the class via -> self.data

  The double underscore is used to define the operators of the functions, and are automatically called via interepreter
  aka magic function. This allows them to replace certain things or have things happen in a manner when something is done.

  Example:
  __repr__: provides the string representation of the object
  __add__: allows u to define the behavior of the addition operator when used with objects of the class
  """
  def __init__(self, data, _children=(), _op=''): # creating children as an immutable list
    self.data = data
    self._prev = set(_children) # set to remove duplicates
  #  Need connective tissue, and want to make this a graph --
  # so we need pointers to know what values create other values
  # Thus prev is introduced
    self._op = _op

  def __repr__(self):
    return f"Value(data={self.data})"

  def __add__(self, other):
    """
    Takes another value, and takes its sellf and then gets its own value and adds it to the other and returns it
    """
    out = Value(self.data + other.data, (self, other), '+') # feed in children of the val, which is a tuple of itself and other
    return out

  def __mul__(self, other):
    out = Value(self.data * other.data , (self, other), '*') # feed in children of the val, which is a tuple of itself and other
    return out

a = Value(2.0)
b = Value(-3.0)
c = Value(10.0)
# Self is a in this instance, and b is the other
d = a*b + c # Which is the same as (a.mul(b)).add(c)
d

d._prev # set of children, which is (a*b) and c

d._op # d was made via addition of the two values

# Now we have a datastructure where we know exactly how each value came to be, like what numbers made it and what operation